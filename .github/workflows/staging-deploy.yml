name: CICD - Staging (Work in progress)

on:
  push: #This is temporary and needs to be removed once this branch is merged
    branches:
      - staging-deploy (temp)
      - staging-workflow (temp)
  workflow_dispatch:
    inputs:
      release_tag:
        description: "Release tag to deploy (e.g., v1.2.3-rc.1 or v1.2.3)"
        required: true
        type: string

permissions:
  id-token: write
  contents: write

env:
  AWS_REGION: ${{ vars.AWS_REGION || 'us-east-1' }}
  DEV_ARTIFACT_BUCKET: ${{ vars.DEV_ARTIFACT_BUCKET || 'ustc-payment-portal-build-artifacts' }}

jobs:
  tag-release:
    if: github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    timeout-minutes: 45
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history for all tags and branches

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Tag Release
        env:
          TAG: ${{ inputs.release_tag }}
        run: |
          set -euo pipefail
          if git rev-parse -q --verify "refs/tags/${TAG}" >/dev/null; then
            echo "Tag ${TAG} already exists; skipping tag creation."
          else
            echo "Creating and pushing tag ${TAG}"
            git tag -a "${TAG}" -m "Release ${TAG}"
            git push origin "${TAG}"
          fi

    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  deploy:
    runs-on: ubuntu-latest
    # needs: tag-release
    environment:
      name: staging

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'workflow_dispatch' && inputs.release_tag || github.sha }}

      #to check of the release tag input isn't empty. just a defensive guard so we dont proceed with undefined tag and deploy wrong code.
      - name: Validate release tag input
        if: github.event_name == 'workflow_dispatch'
        run: |
          set -euo pipefail
          TAG='${{ inputs.release_tag }}'
          if [ -z "${TAG}" ]; then
            echo "release_tag is required" >&2; exit 1
          fi
          echo "Using tag: ${TAG}"

      # finds exact commit sha that the tag points to and should show output as steps.rev.outputs.sha
      - name: Resolve tag commit SHA
        if: github.event_name == 'workflow_dispatch'
        id: rev
        run: |
          set -euo pipefail
          TAG='${{ inputs.release_tag }}'
          SHA=$(git rev-list -n 1 "${TAG}")
          if [ -z "${SHA}" ]; then
            echo "Unable to resolve commit for tag ${TAG}" >&2; exit 1
          fi
          echo "sha=${SHA}" >> $GITHUB_OUTPUT
          echo "Resolved SHA: ${SHA}"

      - name: Export artifact bucket (env)
        run: |
          echo "Dev bucket: $DEV_ARTIFACT_BUCKET"
          echo "Event: ${{ github.event_name }}"
          echo "Ref: ${{ github.ref }}"

      - name: Configure AWS Credentials (OIDC - Stg)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.STAGING_AWS_DEPLOYER_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify AWS caller identity (to be removed later)
        run: aws sts get-caller-identity

      - name: Build artifact key map (dev bucket)
        id: artifacts
        run: |
          set -euo pipefail
          SHA='${{ steps.rev.outputs.sha || github.sha }}'
          PREFIX="artifacts/dev/${SHA}"
          echo "sha=${SHA}" >> $GITHUB_OUTPUT
          echo "initPayment=${PREFIX}/initPayment.zip" >> $GITHUB_OUTPUT
          echo "processPayment=${PREFIX}/processPayment.zip" >> $GITHUB_OUTPUT
          echo "getDetails=${PREFIX}/getDetails.zip" >> $GITHUB_OUTPUT
          echo "testCert=${PREFIX}/testCert.zip" >> $GITHUB_OUTPUT

      # - name: Fetch artifact hashes (to see if tf change is needed)
      #   id: hashes
      #   run: |
      #     set -euo pipefail
      #     get_hash() {
      #       KEY="$1"
      #       aws s3api head-object --bucket "${DEV_ARTIFACT_BUCKET}" --key "${KEY}" \
      #         | jq -r '.Metadata.sha256_b64 // empty'
      #     }
      #     echo "initPayment=$(get_hash '${{ steps.artifacts.outputs.initPayment }}')" >> $GITHUB_OUTPUT
      #     echo "processPayment=$(get_hash '${{ steps.artifacts.outputs.processPayment }}')" >> $GITHUB_OUTPUT
      #     echo "getDetails=$(get_hash '${{ steps.artifacts.outputs.getDetails }}')" >> $GITHUB_OUTPUT
      #     echo "testCert=$(get_hash '${{ steps.artifacts.outputs.testCert }}')" >> $GITHUB_OUTPUT

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false
          terraform_version: ${{ vars.TERRAFORM_VERSION || '1.7.5' }}

      - name: Terraform Init (staging)
        working-directory: terraform/environments/stg
        run: |
          terraform init -input=false -backend-config=backend.hcl -reconfigure

      - name: Terraform Plan (staging)
        id: plan
        working-directory: terraform/environments/stg
        env:
          TF_VAR_artifact_bucket: ${{ env.DEV_ARTIFACT_BUCKET }}
          TF_VAR_initPayment_s3_key: ${{ steps.artifacts.outputs.initPayment }}
          TF_VAR_processPayment_s3_key: ${{ steps.artifacts.outputs.processPayment }}
          TF_VAR_getDetails_s3_key: ${{ steps.artifacts.outputs.getDetails }}
          TF_VAR_testCert_s3_key: ${{ steps.artifacts.outputs.testCert }}
          TF_VAR_initPayment_source_code_hash: ${{ steps.hashes.outputs.initPayment }}
          TF_VAR_processPayment_source_code_hash: ${{ steps.hashes.outputs.processPayment }}
          TF_VAR_getDetails_source_code_hash: ${{ steps.hashes.outputs.getDetails }}
          TF_VAR_testCert_source_code_hash: ${{ steps.hashes.outputs.testCert }}
        run: |
          set -euo pipefail
          terraform plan -input=false -out=tfplan
          terraform show -no-color tfplan > tfplan.txt || true
